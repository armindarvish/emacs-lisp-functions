(defun lf-enumerate (list &optional start-from)
  (let ((i (1- (or start-from 0))))
    (mapcar (lambda (x)
              (setq i (1+ i))
              (cons i x))
            list)))

(defun lf--range-type (start stop)
  (let ((type (if (eq (type-of start) (type-of stop))
                  (type-of start)
                (error "Elements must be of same type."))))
    type))

(defun lf--range-map (x)
  (pcase (type-of x)
    ('integer x)
    ('string (string-to-char x))))

(defun lf-range (from to &optional step)
  (let* ((type (lf--range-type from to))
         (beg (lf--range-map from))
         (end (lf--range-map to)))
    (mapcar (lambda (x)
              (pcase type 
                ('integer x)
                ('string (char-to-string x))))
            (number-sequence beg end (cond (step))))))

(defun lf-array (x &optional to step)
  (if to
      (lf-range x to (cond (step)))
    (let ((init (if (stringp x)
                    "a"
                  1)))
      (lf-range init x))))

(defun lf-map-cons (x y)
    (mapcan (lambda (n)
              (mapcar (lambda (i) (cons n i))
                      x))
            y))

(lf-map-cons '((1) (2)) '(3 4))

(defun lf--table (fn &rest domain)
  (let ((outer (mapcar #'list (car domain))))
    (mapc (lambda (x)
            (setq outer (lf-map-cons outer x)))
          (cdr domain))
    (mapcar (lambda (y) (apply fn y))
            (mapcar #'reverse outer))))

(lf--table (lambda (a b c) (when (= a 1) (+ a b c))) '(1 2) '(3 4) '(5 6))

(defmacro lf-table (fn &rest domain)
  (declare (debug (form &rest form)))
  `(let ((x ',(mapcar (lambda (y)
                        (if (listp (cadr y))
                            (if (fboundp (caadr y))
                                (eval (cadr y))
                              (cadr y))
                          (if (boundp (cadr y))
                              (eval (cadr y))
                          (apply #'lf-array (cdr y)))))
                      domain)))
     (apply #'lf--table (lambda ,(mapcar #'car domain) ,fn)
                x)))

(lf-table (cons a b) (a '(1 2)) (b (buffer-list)))
(delq nil (lf-table (unless (= a 1) (+ a b c)) (a 1 5) (b 3) (c 2 8)))

(ert-deftest lf-array-test ()
  (should (equal (lf-array 3) '(1 2 3)))
  (should (equal (lf-array "c") '("a" "b" "c")))
  (should (equal (lf-array 2 4) '(2 3 4)))
  (should (equal (lf-array "b" "d") '("b" "c" "d")))
  (should (equal (lf-array 1 5 2) '(1 3 5)))
  (should (equal (lf-array "a" "e" 2) '("a" "c" "e")))
  (should (equal (lf-array "z" "A" -20) '("z" "f" "R")))
  (should (equal (lf-table (concat a b c) (a "c") (b "Z" "Y" -1) (c "d" "e"))
                 '("aZd" "bZd" "cZd" "aYd" "bYd" "cYd" "aZe" "bZe" "cZe" "aYe" "bYe" "cYe")))
  (should (equal (lf-table (unless (= b 9)(+ a b c)) (a 8) (b 9 7 -2) (c 6 7))
                 '(16 17 18 19 20 21 22 23 14 15 16 17 18 19 20 21 17 18 19 20 21 22 23 24 15 16 17 18 19 20 21 22))))
